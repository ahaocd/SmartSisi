import threading
import time
from collections import deque


class PlaybackReferenceBuffer:
    def __init__(self, max_ms=2000, sample_rate=16000, sample_width=2):
        self._lock = threading.Lock()
        self._chunks = deque()
        self._size = 0
        self._max_bytes = int(sample_rate * (max_ms / 1000.0) * sample_width)
        self._playing = False
        self._last_play_start = 0.0
        self._last_play_stop = 0.0

    def set_playing(self, playing: bool):
        now = time.time()
        with self._lock:
            if playing and not self._playing:
                self._last_play_start = now
            if not playing and self._playing:
                self._last_play_stop = now
            self._playing = playing

    def is_playing(self) -> bool:
        with self._lock:
            return self._playing

    def last_play_start(self) -> float:
        with self._lock:
            return self._last_play_start

    def last_play_stop(self) -> float:
        with self._lock:
            return self._last_play_stop

    def push_pcm(self, data: bytes):
        if not data:
            return
        with self._lock:
            self._chunks.append(data)
            self._size += len(data)
            while self._size > self._max_bytes and self._chunks:
                removed = self._chunks.popleft()
                self._size -= len(removed)

    def pop_pcm(self, n_bytes: int) -> bytes:
        if n_bytes <= 0:
            return b""
        out = bytearray()
        with self._lock:
            while self._chunks and len(out) < n_bytes:
                chunk = self._chunks[0]
                need = n_bytes - len(out)
                if len(chunk) <= need:
                    out.extend(self._chunks.popleft())
                    self._size -= len(chunk)
                else:
                    out.extend(chunk[:need])
                    self._chunks[0] = chunk[need:]
                    self._size -= need
        if len(out) < n_bytes:
            out.extend(b"\x00" * (n_bytes - len(out)))
        return bytes(out)


_ref_buffer = PlaybackReferenceBuffer()


def set_playing(playing: bool):
    _ref_buffer.set_playing(playing)


def is_playing() -> bool:
    return _ref_buffer.is_playing()


def last_play_start() -> float:
    return _ref_buffer.last_play_start()


def last_play_stop() -> float:
    return _ref_buffer.last_play_stop()


def push_playback_pcm(data: bytes):
    _ref_buffer.push_pcm(data)


def pop_reference_pcm(n_bytes: int) -> bytes:
    return _ref_buffer.pop_pcm(n_bytes)


def should_suppress_input(now_ts: float, hold_ms: int, tail_ms: int) -> bool:
    if hold_ms <= 0 and tail_ms <= 0:
        return False
    playing = _ref_buffer.is_playing()
    if playing:
        start_ts = _ref_buffer.last_play_start()
        if start_ts > 0 and (now_ts - start_ts) * 1000.0 < hold_ms:
            return True
        return False
    stop_ts = _ref_buffer.last_play_stop()
    if stop_ts > 0 and (now_ts - stop_ts) * 1000.0 < tail_ms:
        return True
    return False
