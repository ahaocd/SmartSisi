# sisi_audio_output.py
# ESP32éŸ³é¢‘è¾“å‡ºç®¡ç†å™¨ - å®ç°é˜Ÿåˆ—ç®¡ç†å’Œè¾¹ç•Œæ ‡è®°å¤„ç†
# ä½œè€…: sisi liu
# æ—¥æœŸ: 2025-04-03

import os
import time
import asyncio
import threading
import tempfile
import subprocess
import traceback
import logging
import queue
import audioop
from pathlib import Path
import re
import glob

# å¯¼å…¥ç»Ÿä¸€çš„éŸ³é¢‘å·¥å…·
from utils.stream_util import AudioManagerUtil

class AudioState:
    IDLE = "idle"
    PLAYING = "playing" 
    PAUSED = "paused"
    ERROR = "error"

class AudioOutputManager:
    """æµå¼éŸ³é¢‘è¾“å‡ºç®¡ç†å™¨ - ä¸“æ³¨äºè®¾å¤‡ç«¯éŸ³é¢‘å¤„ç†"""
    
    # ğŸ”¥ å•ä¾‹å®ä¾‹
    _instance = None

    # ä½¿ç”¨ç»Ÿä¸€çš„éŸ³é¢‘å‚æ•°é…ç½®
    # ä½¿ç”¨ç»Ÿä¸€çš„éŸ³é¢‘å‚æ•°é…ç½®
    SAMPLE_RATE = AudioManagerUtil.SAMPLE_RATE
    FRAME_DURATION = AudioManagerUtil.FRAME_DURATION
    FRAME_SIZE = AudioManagerUtil.FRAME_SIZE
    PRE_BUFFER_FRAMES = AudioManagerUtil.PRE_BUFFER_FRAMES

    # ğŸ”¥ 2025-08-15 ä¼˜åŒ–ï¼šESP32-S3æµå¼å¤„ç†å‚æ•°
    CHUNK_SIZE = 2048    # éŸ³é¢‘å—å¤§å°ï¼Œ2KBæ›´é€‚åˆESP32-S3
    MAX_QUEUE_SIZE = 50  # æœ€å¤§é˜Ÿåˆ—é•¿åº¦ï¼Œé˜²æ­¢å†…å­˜æº¢å‡º
    STREAM_TIMEOUT = 0.05 # æµå¼å¤„ç†è¶…æ—¶æ—¶é—´ï¼Œ50msæ›´å¹³æ»‘

    # ä½¿ç”¨ç»Ÿä¸€çš„éŸ³é¢‘æ ‡è®°å¸§å¸¸é‡
    AUDIO_START_MARKER = AudioManagerUtil.AUDIO_START_MARKER
    AUDIO_END_MARKER = AudioManagerUtil.AUDIO_END_MARKER
    HEARTBEAT_MARKER = AudioManagerUtil.HEARTBEAT_MARKER

    # æ—¥å¿—çº§åˆ«å®šä¹‰
    LOG_DEBUG = 0
    LOG_INFO = 1
    LOG_WARN = 2
    LOG_ERROR = 3
    LOG_CRITICAL = 4

    DEFAULT_LOG_LEVEL = LOG_WARN

    @classmethod
    def get_instance(cls):
        """è·å–å•ä¾‹å®ä¾‹"""
        return cls._instance
    
    def __init__(self, logger=None, data_callback=None, state_callback=None, debug_mode=False):
        """åˆå§‹åŒ–éŸ³é¢‘è¾“å‡ºç®¡ç†å™¨
        Args:
            logger: æ—¥å¿—è®°å½•å™¨
            data_callback: éŸ³é¢‘æ•°æ®å›è°ƒå‡½æ•°
            state_callback: çŠ¶æ€å˜åŒ–å›è°ƒå‡½æ•°
            debug_mode: æ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼
        """
        # ğŸ”¥ è®¾ç½®å•ä¾‹å®ä¾‹
        AudioOutputManager._instance = self
        self.logger = logger or logging.getLogger("AudioOutputManager")
        if not self.logger.handlers:
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
            self.logger.addHandler(handler)
            self.logger.setLevel(logging.INFO)
        
        # ğŸ”¥ æµå¼é˜Ÿåˆ—ç³»ç»Ÿ
        self.tts_queue = queue.PriorityQueue(maxsize=self.MAX_QUEUE_SIZE)  # ä¼˜å…ˆçº§é˜Ÿåˆ—
        self.audio_play_queue = queue.Queue(maxsize=self.MAX_QUEUE_SIZE)
        self.stream_chunk_queue = queue.Queue(maxsize=self.MAX_QUEUE_SIZE * 2)  # æµå¼å—é˜Ÿåˆ—

        # ğŸ”¥ ä¿®å¤ï¼šæ·»åŠ ç¼ºå°‘çš„å›è°ƒå±æ€§å¹¶æ­£ç¡®è®¾ç½®
        self.on_play_start = None
        self.on_play_end = None
        self.on_audio_data = data_callback  # æ­£ç¡®è®¾ç½®éŸ³é¢‘æ•°æ®å›è°ƒ
        
        self.state = AudioState.IDLE
        self.abort = False
        self.running = True
        
        # æ·»åŠ ç»Ÿä¸€çš„çŠ¶æ€ç®¡ç†æ ‡å¿—ï¼ˆå‚è€ƒxiaozhi-serverï¼‰
        self.client_is_speaking = False  # åœ¨__init__ä¸­åˆå§‹åŒ–client_is_speakingå±æ€§
        
        self.data_callback = data_callback
        self.state_callback = state_callback
        
        # ğŸ¯ æµå¼éŸ³é¢‘ç´¯è®¡ç»Ÿè®¡ï¼ˆå‡å°‘æ—¥å¿—è¾“å‡ºï¼‰
        self.stream_stats = {
            "total_chunks": 0,
            "total_bytes": 0,
            "last_priority": None,
            "session_start": time.time()
        }
        self._level_interval = 0.04
        self._last_level_ts = 0.0
        self.debug_mode = debug_mode
        # ğŸ”¥ æ¢å¤æ­£å¸¸æ—¥å¿—çº§åˆ«
        self.log_level = self.DEFAULT_LOG_LEVEL
        
        # ğŸ”¥ æ·»åŠ OPUSç¼–ç å™¨å•ä¾‹ï¼Œé¿å…é‡å¤åˆå§‹åŒ–
        self._opus_converter = None
        
        # ğŸ”¥ æ·»åŠ æµæ§çŠ¶æ€ç®¡ç†ï¼ˆå‚è€ƒxiaozhi-serverï¼‰
        self.audio_flow_control = {
            "last_send_time": 0,
            "packet_count": 0,
            "start_time": time.perf_counter(),
            "sequence": 0,  # æ·»åŠ åºåˆ—å·
        }
        
        # æ’å…¥æ§åˆ¶ï¼šæš‚åœ/æ¢å¤
        self._pause_streaming = False
        
        # æ·»åŠ conn_from_mqtt_gatewayå±æ€§ï¼ˆå‚è€ƒxiaozhi-serverï¼‰
        self.conn_from_mqtt_gateway = False
        
        # ğŸ”¥ æµå¼å¤„ç†çº¿ç¨‹
        self.tts_thread = threading.Thread(target=self._process_tts_queue, daemon=True)
        self.audio_thread = threading.Thread(target=self._process_audio_queue, daemon=True)
        self.stream_thread = threading.Thread(target=self._process_stream_chunks, daemon=True)  # æ–°å¢æµå¼å¤„ç†çº¿ç¨‹

        self.tts_thread.start()
        self.audio_thread.start()
        self.stream_thread.start()
        
        self.logger.info("ESP32éŸ³é¢‘è¾“å‡ºç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ")

    def add_opus_frames(self, opus_frames, label: str = "effect", is_final: bool = False) -> bool:
        """ç›´æ¥å‘æ’­æ”¾é˜Ÿåˆ—è¿½åŠ ä¸€æ®µå·²ç¼–ç çš„OPUSå¸§ï¼Œä¸æ‰“æ–­å½“å‰æµå¼ä¼šè¯ã€‚
        Args:
            opus_frames: List[bytes] OPUSå¸§åºåˆ—
            label: é˜Ÿåˆ—é¡¹æ–‡æœ¬æ ‡è¯†ï¼ˆç”¨äºæ—¥å¿—ï¼‰
            is_final: æ˜¯å¦æ ‡è®°ä¸ºæœ€ç»ˆå—ï¼ˆé€šå¸¸ä¸ºFalseï¼Œäº¤ç”±ä¸Šå±‚ç»Ÿä¸€ç»“æŸï¼‰
        Returns:
            bool: æ˜¯å¦å…¥é˜ŸæˆåŠŸ
        """
        try:
            if not opus_frames or len(opus_frames) == 0:
                self.log(self.LOG_WARN, f"è·³è¿‡æ— æ•ˆOPUSå¸§: {label}")
                return False
            
            # ğŸ”¥ ç®€åŒ–é€»è¾‘ï¼šç›´æ¥å…¥é˜Ÿï¼Œç”±æ’­æ”¾çº¿ç¨‹ç»Ÿä¸€å¤„ç†
            self.audio_play_queue.put((label, opus_frames, is_final))
            print(f"[AudioManager] âœ… å…¥é˜Ÿ: {label}, {len(opus_frames)}å¸§")
            return True
        except Exception as e:
            self.log(self.LOG_ERROR, f"å…¥é˜ŸOPUSå¸§å¤±è´¥: {str(e)}")
            import traceback
            traceback.print_exc()
            return False
    
    def _calculate_timestamp_and_sequence(self, start_time, packet_index, frame_duration=60):
        """
        ğŸ”¥ æ–°å¢ï¼šè®¡ç®—éŸ³é¢‘æ•°æ®åŒ…çš„æ—¶é—´æˆ³å’Œåºåˆ—å·ï¼ˆå‚è€ƒxiaozhi-serverï¼‰
        Args:
            start_time: èµ·å§‹æ—¶é—´ï¼ˆæ€§èƒ½è®¡æ•°å™¨å€¼ï¼‰
            packet_index: æ•°æ®åŒ…ç´¢å¼•
            frame_duration: å¸§æ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰ï¼ŒåŒ¹é… Opus ç¼–ç 
        Returns:
            tuple: (timestamp, sequence)
        """
        # è®¡ç®—æ—¶é—´æˆ³ï¼ˆä½¿ç”¨æ’­æ”¾ä½ç½®è®¡ç®—ï¼‰
        timestamp = int((start_time + packet_index * frame_duration / 1000) * 1000) % (
            2**32
        )

        # è®¡ç®—åºåˆ—å·
        sequence = self.audio_flow_control["sequence"]

        return timestamp, sequence

    def _reset_flow_control(self):
        """ğŸ”¥ æ–°å¢ï¼šé‡ç½®æµæ§çŠ¶æ€"""
        self.audio_flow_control = {
            "last_send_time": 0,
            "packet_count": 0,
            "start_time": time.perf_counter(),
            "sequence": 0,  # æ·»åŠ åºåˆ—å·
        }
        self.log(self.LOG_DEBUG, "æµæ§çŠ¶æ€å·²é‡ç½®")

    def set_callbacks(self, on_play_start=None, on_play_end=None, on_audio_data=None):
        """è®¾ç½®å›è°ƒå‡½æ•°
        Args:
            on_play_start: æ’­æ”¾å¼€å§‹å›è°ƒ
            on_play_end: æ’­æ”¾ç»“æŸå›è°ƒ
            on_audio_data: éŸ³é¢‘æ•°æ®å›è°ƒ
        """
        if on_play_start is not None:
            self.on_play_start = on_play_start
        if on_play_end is not None:
            self.on_play_end = on_play_end
        if on_audio_data is not None:
            self.on_audio_data = on_audio_data
            
    def update_state(self, new_state):
        """æ›´æ–°çŠ¶æ€å¹¶é€šçŸ¥å›è°ƒ"""
        # ğŸ”¥ ç®€åŒ–æ—¥å¿—ï¼šåªåœ¨çŠ¶æ€çœŸæ­£å˜åŒ–æ—¶è¾“å‡º
        if self.state != new_state:
            print(f"[AudioManager] çŠ¶æ€: {self.state} â†’ {new_state}")
        
        # ğŸ”¥ ç»Ÿä¸€çŠ¶æ€ç®¡ç†ï¼Œé¿å…ç«æ€æ¡ä»¶ï¼ˆä¿®å¤é€»è¾‘é”™è¯¯ï¼‰
        if new_state == AudioState.PLAYING:
            if not self.client_is_speaking:
                self.client_is_speaking = True
                self.state = new_state
                if self.state_callback:
                    self.state_callback(new_state)
        elif new_state == AudioState.IDLE:
            if self.client_is_speaking:
                self.client_is_speaking = False
                self.state = new_state
                if self.state_callback:
                    self.state_callback(new_state)
        else:
            # å…¶ä»–çŠ¶æ€å˜åŒ–
            self.state = new_state
            if self.state_callback:
                self.state_callback(new_state)

    def _push_audio_level(self, pcm_bytes):
        """å‘WebUIå‘é€éŸ³é‡çº§åˆ«ï¼ˆRMSï¼‰"""
        try:
            if not pcm_bytes or len(pcm_bytes) < 2:
                return
            now = time.time()
            if now - self._last_level_ts < self._level_interval:
                return
            rms = audioop.rms(pcm_bytes, 2)
            level = min(1.0, max(0.0, rms / 32768.0))
            from core import wsa_server
            web_instance = wsa_server.get_web_instance()
            if web_instance:
                web_instance.add_cmd({"audio_level": level})
            self._last_level_ts = now
        except Exception:
            pass

    def send_audio_data(self, audio_data, client_callback=None):
        """ç»Ÿä¸€çš„éŸ³é¢‘å‘é€å¤„ç†
        Args:
            audio_data: éŸ³é¢‘æ•°æ®
            client_callback: å®¢æˆ·ç«¯å›è°ƒå‡½æ•°,ä¼˜å…ˆçº§é«˜äºdata_callback
        """
        try:
            callback = client_callback or self.data_callback
            if not callback:
                self.log(self.LOG_ERROR, "æœªè®¾ç½®éŸ³é¢‘æ•°æ®å›è°ƒ")
                return False
                
            # ä½¿ç”¨ç»Ÿä¸€çš„éŸ³é¢‘å¤„ç†å·¥å…·åˆ†å‰²å¸§
            frames = AudioManagerUtil.split_audio_to_frames(audio_data)
            if not frames:
                return False
                
            # æ·»åŠ æ ‡è®°å¸§
            marked_frames = AudioManagerUtil.add_markers_to_frames(frames)
            
            # å‘é€æ‰€æœ‰å¸§
            for frame in marked_frames:
                callback(frame)
                # æ§åˆ¶å‘é€é€Ÿç‡
                time.sleep(0.001)  # 1mså»¶è¿Ÿ
            
            return True
            
        except Exception as e:
            self.log(self.LOG_ERROR, f"å‘é€éŸ³é¢‘æ•°æ®å¼‚å¸¸: {str(e)}")
            traceback.print_exc()
            return False

    def _convert_to_opus(self, audio_file):
        """è½¬æ¢éŸ³é¢‘æ–‡ä»¶ä¸ºopusæ ¼å¼
        Args:
            audio_file: éŸ³é¢‘æ–‡ä»¶è·¯å¾„
        Returns:
            opus_dataåˆ—è¡¨
        """
        # ä½¿ç”¨ç»Ÿä¸€çš„éŸ³é¢‘å·¥å…·è¿›è¡Œè½¬æ¢
        return AudioManagerUtil.convert_to_opus_frames(audio_file)

    def _convert_raw_audio_to_opus(self, raw_audio_data):
        """å°†åŸå§‹éŸ³é¢‘æ•°æ®è½¬æ¢ä¸ºOPUSæ ¼å¼ï¼ˆæµå¼è½¬æ¢ï¼‰
        ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šä¿æŒç¼–ç å™¨çŠ¶æ€è¿ç»­ï¼Œä¸åœ¨æµä¸­é‡ç½®
        """
        try:
            # ğŸ”¥ ä¿®å¤ï¼šç§»é™¤100å­—èŠ‚é™åˆ¶ï¼Œè®©ç¼–ç å™¨å†…éƒ¨ç¼“å†²å¤„ç†
            if not raw_audio_data:
                return None

            pcm_data = raw_audio_data
            self.log(self.LOG_DEBUG, f"å¤„ç†PCMæ•°æ®: {len(pcm_data)}å­—èŠ‚")

            # ç¡®ä¿PCMæ•°æ®é•¿åº¦æ˜¯å¶æ•°ï¼ˆ16bité‡‡æ ·ï¼‰
            if len(pcm_data) % 2 != 0:
                pcm_data = pcm_data[:-1]

            if len(pcm_data) == 0:
                return None

            # ä½¿ç”¨OPUSåº“è½¬æ¢PCMæ•°æ®
            try:
                from esp32_liusisi.opus_helper import OpusConvertor

                # ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨å•ä¾‹æ¨¡å¼ï¼Œä¸åœ¨æµä¸­é‡ç½®ç¼–ç å™¨
                if self._opus_converter is None:
                    self._opus_converter = OpusConvertor(debug=False)  # ğŸ”¥ å…³é—­è°ƒè¯•
                    self.log(self.LOG_INFO, "åˆ›å»ºOPUSç¼–ç å™¨å®ä¾‹")

                # ğŸ”¥ å…³é”®ï¼šä¸è¦åœ¨è¿™é‡Œé‡ç½®ç¼–ç å™¨ï¼è®©ç¼–ç å™¨ä¿æŒçŠ¶æ€è¿ç»­

                opus_frames = []
                def collect_opus_frame(opus_frame):
                    opus_frames.append(opus_frame)
                    if len(opus_frames) <= 3 or len(opus_frames) % 20 == 0:
                        self.log(self.LOG_DEBUG, f"OPUSå¸§ #{len(opus_frames)}: {len(opus_frame)}å­—èŠ‚")

                # ç›´æ¥æµå¼ç¼–ç PCMæ•°æ®ï¼Œä¸è®¾ç½®end_of_stream
                self._opus_converter.encode_pcm_to_opus_stream(
                    pcm_data,
                    end_of_stream=False,  # ğŸ”¥ å…³é”®ï¼šä¸æ ‡è®°æµç»“æŸ
                    callback=collect_opus_frame
                )

                # ğŸ”¥ å³ä½¿æ²¡æœ‰äº§ç”Ÿå®Œæ•´å¸§ä¹Ÿè¿”å›ç©ºåˆ—è¡¨ï¼Œè€Œä¸æ˜¯None
                return opus_frames if opus_frames else []
                    
            except Exception as e:
                self.log(self.LOG_ERROR, f"PCMè½¬OPUSå¼‚å¸¸: {str(e)}")
                traceback.print_exc()
                return None
        except Exception as e:
            self.log(self.LOG_ERROR, f"PCMè½¬OPUSå¼‚å¸¸: {str(e)}")
            traceback.print_exc()
            return None

    def log(self, level, message):
        """è®°å½•æ—¥å¿—ï¼ŒæŒ‰çº§åˆ«è¾“å‡º
        Args:
            level: æ—¥å¿—çº§åˆ«
            message: æ—¥å¿—ä¿¡æ¯
        """
        # ä½äºå½“å‰æ—¥å¿—çº§åˆ«çš„æ—¥å¿—ä¸è¾“å‡º
        if level < self.log_level:
            return
            
        level_prefix = {
            self.LOG_DEBUG: "[DEBUG]",
            self.LOG_INFO: "[INFO]",
            self.LOG_WARN: "[WARN]",
            self.LOG_ERROR: "[ERROR]",
            self.LOG_CRITICAL: "[CRITICAL]"
        }.get(level, "[INFO]")
        
        self.logger.info(f"{level_prefix} AudioManager: {message}")
    
    def set_callbacks(self, on_play_start=None, on_play_end=None, on_audio_data=None):
        """è®¾ç½®å›è°ƒå‡½æ•°"""
        self.on_play_start = on_play_start
        self.on_play_end = on_play_end
        self.on_audio_data = on_audio_data
        self.log(1, "å·²è®¾ç½®å›è°ƒå‡½æ•°")

    def is_streaming(self):
        """æŸ¥è¯¢å½“å‰æ˜¯å¦å¤„äºæµå¼æ’­æ”¾çŠ¶æ€"""
        return self.state == AudioState.PLAYING or self.client_is_speaking
    
    def add_tts_task(self, text, audio_file, priority=0):
        """æ·»åŠ TTSä»»åŠ¡åˆ°é˜Ÿåˆ—
        Args:
            text: TTSæ–‡æœ¬å†…å®¹
            audio_file: éŸ³é¢‘æ–‡ä»¶è·¯å¾„
            priority: ä¼˜å…ˆçº§ï¼Œå…¼å®¹SmartSisiç³»ç»Ÿï¼ˆæ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
        """
        try:
            if not os.path.exists(audio_file):
                self.log(self.LOG_WARN, f"éŸ³é¢‘æ–‡ä»¶ä¸å­˜åœ¨: {audio_file}")
                return False

            # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯ä»¥è®¿é—®ä¸”éç©º
            if not os.access(audio_file, os.R_OK):
                self.log(self.LOG_WARN, f"éŸ³é¢‘æ–‡ä»¶æ— æ³•è®¿é—®: {audio_file}")
                return False

            if os.path.getsize(audio_file) == 0:
                self.log(self.LOG_WARN, f"éŸ³é¢‘æ–‡ä»¶ä¸ºç©º: {audio_file}")
                return False

            # ğŸ”¥ ä¿®å¤ï¼šè½¬æ¢SmartSisiä¼˜å…ˆçº§åˆ°Pythoné˜Ÿåˆ—ä¼˜å…ˆçº§
            # SmartSisi: æ•°å­—è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜ (7 > 3 > 1)
            # Pythoné˜Ÿåˆ—: æ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ (0 > 1 > 7)
            # è½¬æ¢å…¬å¼: queue_priority = 100 - priority
            queue_priority = 100 - priority

            # æ”¾å…¥ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæ ¼å¼ä¸º(è½¬æ¢åä¼˜å…ˆçº§, (æ–‡æœ¬, éŸ³é¢‘æ–‡ä»¶))
            self.tts_queue.put((queue_priority, (text, audio_file)))
            self.log(self.LOG_WARN, f"æ·»åŠ ä»»åŠ¡: {os.path.basename(audio_file)}, SmartSisiä¼˜å…ˆçº§: {priority}, é˜Ÿåˆ—ä¼˜å…ˆçº§: {queue_priority}")
            return True
        except Exception as e:
            self.log(self.LOG_ERROR, f"æ·»åŠ TTSä»»åŠ¡å¤±è´¥: {str(e)}")
            traceback.print_exc()
            return False

    def add_stream_chunk(self, chunk_data, priority=0, is_final=False):
        """æ·»åŠ æµå¼éŸ³é¢‘å—åˆ°é˜Ÿåˆ—
        Args:
            chunk_data: éŸ³é¢‘å—æ•°æ®
            priority: ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
            is_final: æ˜¯å¦ä¸ºæœ€åä¸€å—
        """
        try:
            if not chunk_data and not is_final:
                return False

            # ğŸ”¥ ä¿®å¤ï¼šè¿‡æ»¤æ‰å¤ªå°çš„éŸ³é¢‘å—ï¼ˆå°äº100å­—èŠ‚ï¼‰ï¼Œé™¤äº†æœ€åä¸€å—
            if chunk_data and len(chunk_data) < 100 and not is_final:
                self.log(self.LOG_DEBUG, f"è·³è¿‡å¤ªå°çš„éŸ³é¢‘å—: {len(chunk_data)}å­—èŠ‚")
                return False

            # ğŸ¯ ç´¯è®¡ç»Ÿè®¡ï¼Œå‡å°‘æ—¥å¿—è¾“å‡º
            self.stream_stats["total_chunks"] += 1
            self.stream_stats["total_bytes"] += len(chunk_data) if chunk_data else 0
            self.stream_stats["last_priority"] = priority
            
            # åªåœ¨æœ€åä¸€å—æˆ–æ¯50å—è¾“å‡ºä¸€æ¬¡ç»Ÿè®¡
            if is_final or self.stream_stats["total_chunks"] % 50 == 0:
                print(f"[AudioManager] ğŸ“¥ æµå¼: {self.stream_stats['total_chunks']}å—/{self.stream_stats['total_bytes']}å­—èŠ‚")

            # æ”¾å…¥æµå¼å—é˜Ÿåˆ—ï¼Œæ ¼å¼ä¸º(ä¼˜å…ˆçº§, (å—æ•°æ®, æ˜¯å¦æœ€åä¸€å—))
            self.stream_chunk_queue.put((priority, (chunk_data, is_final)))
            self.log(self.LOG_DEBUG, f"æ·»åŠ æµå¼å—: {len(chunk_data)}å­—èŠ‚, ä¼˜å…ˆçº§: {priority}, æœ€åå—: {is_final}")
            
            # å¦‚æœæ˜¯æœ€åä¸€å—ï¼Œé‡ç½®ç»Ÿè®¡
            if is_final:
                self.stream_stats = {
                    "total_chunks": 0,
                    "total_bytes": 0,
                    "last_priority": None,
                    "session_start": time.time()
                }
            
            return True
        except Exception as e:
            # ğŸ”¥ åˆ é™¤ç–¯ç‹‚åˆ·å±çš„è°ƒè¯•æ—¥å¿—
            self.log(self.LOG_ERROR, f"æ·»åŠ æµå¼å—å¤±è´¥: {str(e)}")
            return False
    
    def abort_current_playback(self):
        """ä¸­æ­¢å½“å‰æ’­æ”¾"""
        if self.state == AudioState.PLAYING:
            self.abort = True
            self.log(self.LOG_INFO, "å·²è¯·æ±‚ä¸­æ­¢å½“å‰æ’­æ”¾")
            return True
        return False
    
    def clear_queues(self):
        """æ¸…ç©ºæ‰€æœ‰é˜Ÿåˆ—"""
        # æ¸…ç©ºTTSé˜Ÿåˆ—
        while not self.tts_queue.empty():
            try:
                self.tts_queue.get_nowait()
                self.tts_queue.task_done()
            except queue.Empty:
                break
        
        # æ¸…ç©ºéŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—
        while not self.audio_play_queue.empty():
            try:
                self.audio_play_queue.get_nowait()
                self.audio_play_queue.task_done()
            except queue.Empty:
                break
        
        # æ¸…ç©ºæµå¼å—é˜Ÿåˆ—
        while not self.stream_chunk_queue.empty():
            try:
                self.stream_chunk_queue.get_nowait()
                self.stream_chunk_queue.task_done()
            except queue.Empty:
                break

        self.log(self.LOG_INFO, "å·²æ¸…ç©ºæ‰€æœ‰éŸ³é¢‘é˜Ÿåˆ—")
    
    def start_audio_file_monitor(self, directory='samples', pattern='sample-*.wav'):
        """å¯åŠ¨éŸ³é¢‘æ–‡ä»¶ç›‘æ§
        Args:
            directory: ç›‘æ§ç›®å½•
            pattern: æ–‡ä»¶åŒ¹é…æ¨¡å¼ï¼Œé»˜è®¤sample-*.wav
        """
        # åœæ­¢ç°æœ‰ç›‘æ§
        self.stop_audio_file_monitor()
        
        # è®¾ç½®ç›‘æ§å‚æ•°
        self.monitor_directory = os.path.abspath(directory)
        self.monitor_pattern = pattern
        self.monitor_running = True
        
        # åˆ¤æ–­æ˜¯å¦å·²æœ‰æ­¤ç›®å½•çš„ç›‘æ§
        monitor_key = f"{self.monitor_directory}:{pattern}"
        if hasattr(self, 'monitored_directories') and monitor_key in self.monitored_directories:
            self.log(self.LOG_INFO, f"ç›®å½•å·²åœ¨ç›‘æ§ä¸­: {monitor_key}")
            return True
        
        # åˆå§‹åŒ–å·²å¤„ç†æ–‡ä»¶è®°å½•
        if not hasattr(self, 'processed_files'):
            self.processed_files = set()
        if not hasattr(self, 'monitored_directories'):
            self.monitored_directories = set()
        
        # æ·»åŠ åˆ°ç›‘æ§ç›®å½•é›†åˆ
        self.monitored_directories.add(monitor_key)
        
        # åˆå§‹æ‰«æå½“å‰ç›®å½•çš„æ‰€æœ‰æ–‡ä»¶å¹¶æ ‡è®°ä¸ºå·²å¤„ç†
        initial_files = glob.glob(os.path.join(self.monitor_directory, self.monitor_pattern))
        if initial_files:
            self.log(self.LOG_INFO, f"åˆå§‹æ‰«æ: {self.monitor_directory} ä¸­æœ‰ {len(initial_files)} ä¸ªéŸ³é¢‘æ–‡ä»¶")
            for file_path in initial_files:
                self.processed_files.add(file_path)
        
        if not os.path.exists(self.monitor_directory):
            self.log(self.LOG_WARN, f"ç›‘æ§ç›®å½•ä¸å­˜åœ¨: {self.monitor_directory}")
            return False
        
        # å¯åŠ¨ç›‘æ§çº¿ç¨‹
        monitor_thread = threading.Thread(
            target=self._monitor_audio_files,
            args=(self.monitor_directory, self.monitor_pattern),
            daemon=True
        )
        monitor_thread.start()
        
        # ä¿å­˜çº¿ç¨‹å¼•ç”¨
        if not hasattr(self, 'monitor_threads'):
            self.monitor_threads = []
        self.monitor_threads.append(monitor_thread)
        
        self.log(self.LOG_INFO, f"å·²å¯åŠ¨éŸ³é¢‘æ–‡ä»¶ç›‘æ§: {self.monitor_directory}/{self.monitor_pattern}")
        return True
    
    def stop_audio_file_monitor(self):
        """åœæ­¢éŸ³é¢‘æ–‡ä»¶ç›‘æ§"""
        self.monitor_running = False
        
        # ç­‰å¾…æ‰€æœ‰ç›‘æ§çº¿ç¨‹ç»“æŸ
        if hasattr(self, 'monitor_threads'):
            for thread in self.monitor_threads:
                if thread.is_alive():
                    thread.join(timeout=1.0)
            self.monitor_threads = []
        
        # æ¸…ç©ºç›‘æ§è®°å½•
        if hasattr(self, 'monitored_directories'):
            self.monitored_directories = set()
        
        self.log(self.LOG_INFO, "å·²åœæ­¢æ‰€æœ‰éŸ³é¢‘æ–‡ä»¶ç›‘æ§")
    
    def _process_tts_queue(self):
        """TTSé˜Ÿåˆ—å¤„ç†çº¿ç¨‹"""
        while self.running:
            try:
                # è·å–TTSä»»åŠ¡
                priority, task = self.tts_queue.get(timeout=1.0)
                
                # æ£€æŸ¥æ˜¯å¦ä¸ºæ¯’ä¸¸æ¶ˆæ¯
                if priority == -999 and task is None:
                    break
                
                if task:
                    text, audio_file = task
                    self.log(self.LOG_INFO, f"å¤„ç†TTSä»»åŠ¡: {text[:30]}...")
                    
                    try:
                        # è½¬æ¢éŸ³é¢‘æ–‡ä»¶ä¸ºopusæ ¼å¼å¸§åˆ—è¡¨
                        opus_datas = self._convert_to_opus(audio_file)
                        if opus_datas:
                            # æ”¾å…¥éŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—
                            self.audio_play_queue.put((text, opus_datas))
                        else:
                            self.log(self.LOG_WARN, f"è½¬æ¢éŸ³é¢‘å¤±è´¥: {audio_file}")
                    except Exception as e:
                        self.log(self.LOG_ERROR, f"å¤„ç†TTSä»»åŠ¡å¼‚å¸¸: {str(e)}")
                        traceback.print_exc()
                
                # æ ‡è®°ä»»åŠ¡å®Œæˆ
                self.tts_queue.task_done()
            
            except queue.Empty:
                # é˜Ÿåˆ—è¶…æ—¶ï¼Œç»§ç»­å¾ªç¯
                pass
            except Exception as e:
                self.log(self.LOG_ERROR, f"TTSé˜Ÿåˆ—å¤„ç†å¼‚å¸¸: {str(e)}")
                traceback.print_exc()
                time.sleep(1)  # å¼‚å¸¸æƒ…å†µä¸‹æš‚åœä¸€ä¸‹

    def is_idle(self):
        """æ˜¯å¦ç©ºé—²ï¼ˆæ— æ’­æ”¾/ä¼šè¯ç»“æŸä¸”é˜Ÿåˆ—ç©ºï¼‰"""
        return (
            self.state == AudioState.IDLE and
            self.audio_play_queue.empty() and
            self.stream_chunk_queue.empty()
        )

    def pause_streaming(self):
        """æš‚åœæµå¼PCMæ¨è¿›ï¼ˆä¸ä¸¢å¸§ï¼Œæš‚å­˜äºstream_chunk_queueä¸å†…éƒ¨ç¼“å†²ï¼‰"""
        self._pause_streaming = True
        self.log(self.LOG_INFO, "å·²æš‚åœæµå¼PCMæ¨è¿›")

    def resume_streaming(self):
        """æ¢å¤æµå¼PCMæ¨è¿›"""
        self._pause_streaming = False
        self.log(self.LOG_INFO, "å·²æ¢å¤æµå¼PCMæ¨è¿›")

    def wait_until_idle(self, timeout: float = 5.0):
        """ç­‰å¾…æ’­æ”¾ç©ºé—²ï¼ˆé˜»å¡ï¼‰"""
        start = time.time()
        while time.time() - start < timeout:
            if self.is_idle():
                return True
            time.sleep(0.05)
        return False

    def _process_stream_chunks(self):
        """æµå¼éŸ³é¢‘å—å¤„ç†çº¿ç¨‹ - æŒ‰OPUSå¸§å¤§å°å¤„ç†"""
        # ğŸ”¥ ä¿®å¤ï¼šç´¯ç§¯åˆ°å®Œæ•´OPUSå¸§å¤§å°ï¼ˆ1920å­—èŠ‚ = 60ms @16kHzï¼‰
        accumulated_data = bytearray()
        OPUS_FRAME_SIZE = 1920  # 60ms @ 16kHz = 960 samples * 2 bytes
        session_started = False

        while self.running:
            try:
                # æ”¯æŒæš‚åœï¼šæš‚åœæ—¶ä¸æ¶ˆè´¹é˜Ÿåˆ—ï¼Œä½†ä¿æŒçº¿ç¨‹æ´»è·ƒ
                if self._pause_streaming:
                    time.sleep(0.02)
                    continue

                # è·å–æµå¼éŸ³é¢‘å—
                priority, chunk_data = self.stream_chunk_queue.get(timeout=0.1)

                # æ£€æŸ¥æ˜¯å¦ä¸ºæ¯’ä¸¸æ¶ˆæ¯
                if priority == -999 and chunk_data is None:
                    break

                if chunk_data:
                    chunk, is_final = chunk_data

                    # ğŸ”¥ æ–°ä¼šè¯å¼€å§‹æ—¶é‡ç½®ç¼–ç å™¨ï¼ˆåªé‡ç½®ä¸€æ¬¡ï¼‰
                    if not session_started and chunk:
                        session_started = True
                        if hasattr(self, '_opus_converter') and self._opus_converter:
                            self._opus_converter.reset_encoder()
                            self.log(self.LOG_INFO, f"ğŸ”„ æ–°TTSä¼šè¯ï¼Œé‡ç½®OPUSç¼–ç å™¨")

                    # ç´¯ç§¯æ•°æ®
                    if chunk:
                        accumulated_data.extend(chunk)

                    # ğŸ”¥ å…³é”®ï¼šç´¯ç§¯å¤Ÿä¸€ä¸ªOPUSå¸§æˆ–æµç»“æŸæ—¶å¤„ç†
                    while len(accumulated_data) >= OPUS_FRAME_SIZE:
                        # å–å‡ºä¸€ä¸ªå®Œæ•´å¸§
                        frame_data = bytes(accumulated_data[:OPUS_FRAME_SIZE])
                        accumulated_data = accumulated_data[OPUS_FRAME_SIZE:]

                        self.log(self.LOG_DEBUG, f"å¤„ç†å®Œæ•´OPUSå¸§: {OPUS_FRAME_SIZE}å­—èŠ‚")
                        self._process_complete_stream([frame_data], priority, is_final=False)

                    # æµç»“æŸæ—¶å¤„ç†å‰©ä½™æ•°æ®å’Œflush
                    if is_final:
                        if accumulated_data:
                            # å¤„ç†å‰©ä½™æ•°æ®ï¼ˆå¯èƒ½ä¸è¶³ä¸€å¸§ï¼‰
                            self.log(self.LOG_INFO, f"å¤„ç†å‰©ä½™æ•°æ®: {len(accumulated_data)}å­—èŠ‚")
                            self._process_complete_stream([bytes(accumulated_data)], priority, is_final=False)
                            accumulated_data.clear()

                        # Flushç¼–ç å™¨
                        self.log(self.LOG_INFO, f"æµå¼éŸ³é¢‘ç»“æŸï¼Œflushç¼–ç å™¨")
                        self._process_complete_stream([b''], priority, is_final=True)
                        session_started = False

                # æ ‡è®°ä»»åŠ¡å®Œæˆ
                self.stream_chunk_queue.task_done()

            except queue.Empty:
                # é˜Ÿåˆ—ä¸ºç©ºï¼Œç»§ç»­ç­‰å¾…
                continue
            except Exception as e:
                self.log(self.LOG_ERROR, f"æµå¼å—å¤„ç†å¼‚å¸¸: {str(e)}")
                traceback.print_exc()
                time.sleep(0.1)

    def _process_complete_stream(self, stream_chunks, priority, is_final=False):
        """å¤„ç†å®Œæ•´çš„éŸ³é¢‘æµ
        Args:
            stream_chunks: éŸ³é¢‘å—åˆ—è¡¨
            priority: ä¼˜å…ˆçº§
            is_final: æ˜¯å¦ä¸ºæœ€åä¸€å—ï¼ˆéœ€è¦flushç¼–ç å™¨ï¼‰
        """
        try:
            # å¦‚æœæ˜¯æœ€ç»ˆå—ä¸”æ•°æ®ä¸ºç©ºï¼Œåªflushç¼–ç å™¨
            if is_final and stream_chunks == [b'']:
                self.log(self.LOG_INFO, "ğŸ Flush OPUSç¼–ç å™¨")
                if hasattr(self, '_opus_converter') and self._opus_converter:
                    try:
                        # Flushç¼–ç å™¨è·å–å‰©ä½™å¸§
                        from esp32_liusisi.opus_helper import OpusConvertor
                        flush_frames = []
                        def collect_flush_frame(frame):
                            flush_frames.append(frame)

                        # å‘é€ç©ºæ•°æ®å¹¶æ ‡è®°æµç»“æŸä»¥flush
                        self._opus_converter.encode_pcm_to_opus_stream(
                            b'',
                            end_of_stream=True,  # ğŸ”¥ å…³é”®ï¼šæ ‡è®°æµç»“æŸä»¥flush
                            callback=collect_flush_frame
                        )

                        if flush_frames:
                            # ä¼ é€’ is_final æ ‡è®°ï¼Œç¡®ä¿åªåœ¨æœ€åä¸€æ¬¡å‘é€ç»“æŸæ ‡è®°
                            self.audio_play_queue.put(("æµå¼éŸ³é¢‘(flush)", flush_frames, True))
                            self.log(self.LOG_INFO, f"âœ… Flushå®Œæˆ: {len(flush_frames)}å¸§")
                    except Exception as e:
                        self.log(self.LOG_ERROR, f"Flushç¼–ç å™¨å¤±è´¥: {str(e)}")
                return

            if not stream_chunks:
                self.log(self.LOG_WARN, "âš ï¸ ç©ºçš„éŸ³é¢‘æµå—åˆ—è¡¨")
                return

            # åˆå¹¶æ‰€æœ‰éŸ³é¢‘å—
            combined_audio = b''.join(stream_chunks)

            self.log(self.LOG_INFO, f"ğŸ”„ å¤„ç†æµå¼éŸ³é¢‘: {len(stream_chunks)}å—, æ€»å¤§å°: {len(combined_audio)}å­—èŠ‚, ä¼˜å…ˆçº§: {priority}")

            # å‘WebUIæ¨é€éŸ³é‡çº§åˆ«ï¼ˆRMSï¼‰ï¼Œç”¨äºå˜´å‹
            self._push_audio_level(combined_audio)

            # è½¬æ¢ä¸ºOPUSæ ¼å¼ï¼ˆæµå¼è½¬æ¢ï¼Œä¸è®¾ç½®end_of_streamï¼‰
            opus_frames = self._convert_raw_audio_to_opus(combined_audio)
            # ğŸ”¥ ä¿®å¤ï¼šåªæœ‰å½“æœ‰å®é™…å¸§äº§ç”Ÿæ—¶æ‰æ”¾å…¥é˜Ÿåˆ—
            if opus_frames and len(opus_frames) > 0:
                # æ”¾å…¥éŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—
                # ä¼ é€’ is_final æ ‡è®°ï¼ˆæ­¤è·¯å¾„éæœ€ç»ˆå—ï¼‰
                self.audio_play_queue.put(("æµå¼éŸ³é¢‘", opus_frames, False))
                self.log(self.LOG_INFO, f"âœ… æµå¼éŸ³é¢‘å·²åŠ å…¥æ’­æ”¾é˜Ÿåˆ—: {len(opus_frames)}å¸§")
                self.log(self.LOG_DEBUG, f"å·²å°† {len(opus_frames)} å¸§éŸ³é¢‘æ•°æ®æ”¾å…¥æ’­æ”¾é˜Ÿåˆ—")
            # ğŸ”¥ ä¸å†æŠ¥é”™ï¼Œå› ä¸ºæ•°æ®å¯èƒ½è¢«ç¼“å†²åœ¨ç¼–ç å™¨å†…éƒ¨

        except Exception as e:
            self.log(self.LOG_ERROR, f"å¤„ç†å®Œæ•´æµå¼‚å¸¸: {str(e)}")
            traceback.print_exc()
    
    def _process_audio_queue(self):
        """å¤„ç†éŸ³é¢‘é˜Ÿåˆ—"""
        # å…³é”®ä¿®æ”¹ï¼šæ·»åŠ æµå¼ä¼šè¯æ ‡è¯†å’ŒçŠ¶æ€ç®¡ç†
        streaming_session_active = False
        total_frames_in_session = 0
        last_state_change_time = 0
        # å¢åŠ çŠ¶æ€å˜åŒ–å†·å´æ—¶é—´ï¼Œä»0.5ç§’å¢åŠ åˆ°1.0ç§’ï¼Œé¿å…è¿‡äºé¢‘ç¹çš„çŠ¶æ€åˆ‡æ¢
        state_change_cooldown = 1.0  # çŠ¶æ€å˜åŒ–å†·å´æ—¶é—´ï¼ˆç§’ï¼‰

        while self.running:
            try:
                # æ”¯æŒæš‚åœï¼šæš‚åœæ—¶ä»å…è®¸å¤„ç†å·²å…¥é˜Ÿçš„æ•´æ–‡ä»¶ä»»åŠ¡ï¼ˆæ’é˜Ÿï¼‰ï¼Œä½†ä¸ä»æµå¼ç¼“å†²æ–°å¢æ¨è¿›
                if self._pause_streaming and self.audio_play_queue.empty():
                    # æ²¡æœ‰æ•´æ–‡ä»¶ä»»åŠ¡ä¹Ÿä¸æ¨è¿›
                    time.sleep(0.02)
                    continue

                # æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
                if self.audio_play_queue.empty():
                    # åªæœ‰åœ¨æµå¼ä¼šè¯ç»“æŸåæ‰è®¾ç½®ä¸ºIDLEï¼Œå¹¶ä¸”éœ€è¦å†·å´æ—¶é—´
                    current_time = time.time()
                    if streaming_session_active and total_frames_in_session > 0 and \
                       (current_time - last_state_change_time) > state_change_cooldown:
                        self.log(self.LOG_INFO, f"[AudioManager] æµå¼ä¼šè¯ç»“æŸï¼Œå…±{total_frames_in_session}å¸§")
                        self.update_state(AudioState.IDLE)
                        streaming_session_active = False
                        total_frames_in_session = 0
                        # é‡ç½®æµæ§çŠ¶æ€
                        self._reset_flow_control()
                        last_state_change_time = current_time
                    time.sleep(0.1)
                    continue

                # è·å–ä¸‹ä¸€ä¸ªéŸ³é¢‘ä»»åŠ¡
                task = self.audio_play_queue.get(timeout=1.0)
                # ğŸ”¥ åˆ é™¤ç–¯ç‹‚åˆ·å±çš„è°ƒè¯•æ—¥å¿— - åªåœ¨é˜Ÿåˆ—æœ‰å˜åŒ–æ—¶è¾“å‡º
                if not task:
                    continue

                # è®¾ç½®å½“å‰ä»»åŠ¡
                self.current_audio_task = task

                # å¤„ç†éŸ³é¢‘æ•°æ®
                if isinstance(task, tuple) and (len(task) == 2 or len(task) == 3):
                    # å…¼å®¹æ—§æ ¼å¼ (text, frames) ä¸æ–°æ ¼å¼ (text, frames, is_final)
                    text = task[0]
                    opus_datas = task[1]
                    is_final_chunk = (task[2] if len(task) == 3 else True)

                    # è·³è¿‡ç©ºæ•°æ®
                    if not opus_datas or len(opus_datas) == 0:
                        self.log(self.LOG_WARN, f"è·³è¿‡æ— æ•ˆéŸ³é¢‘æ•°æ®: ç©ºopus_datasåˆ—è¡¨")
                        self.audio_play_queue.task_done()
                        continue

                    # æ ¸å¿ƒä¿®æ”¹ï¼šåªåœ¨ä¼šè¯å¼€å§‹æ—¶è®¾ç½®PLAYINGï¼Œå¹¶åœ¨ç¬¬ä¸€æ¬¡æœ‰æ•ˆå—å‰å‘é€å¼€å§‹æ ‡è®°
                    current_time = time.time()
                    if not streaming_session_active and \
                       (current_time - last_state_change_time) > state_change_cooldown:
                        self.update_state(AudioState.PLAYING)
                        streaming_session_active = True
                        self.log(self.LOG_INFO, f"[AudioManager] æµå¼ä¼šè¯å¼€å§‹")
                        # é‡ç½®æµæ§çŠ¶æ€ç”¨äºæ–°ä¼šè¯
                        self._reset_flow_control()
                        last_state_change_time = current_time
                        # å‘é€éŸ³é¢‘å¼€å§‹æ ‡è®°ï¼ˆä¼šè¯é¦–æ¬¡ï¼‰
                        if self.on_audio_data:
                            self.on_audio_data(self.AUDIO_START_MARKER)
                            self.log(self.LOG_DEBUG, "å‘é€éŸ³é¢‘å¼€å§‹æ ‡è®°ï¼ˆä¼šè¯é¦–æ¬¡ï¼‰")

                    total_frames_in_session += len(opus_datas)
                    self.abort = False

                    try:
                        # è°ƒç”¨æ’­æ”¾å¼€å§‹å›è°ƒ
                        if self.on_play_start:
                            self.on_play_start(text)

                        # ä½¿ç”¨opus_datasåˆ—è¡¨çš„æ¯ä¸€é¡¹ä½œä¸ºä¸€ä¸ªéŸ³é¢‘å—
                        total_chunks = len(opus_datas)
                        self.log(self.LOG_INFO, f"å‡†å¤‡å¤„ç† {total_chunks} ä¸ªéŸ³é¢‘æ•°æ®å—")

                        # ä»…åœ¨ä¼šè¯é¦–å—è¿›è¡Œé¢„ç¼“å†²ï¼Œåç»­å—ä¸å†é¢„ç¼“å†²ï¼Œé¿å…èŠ‚æ‹è¢«åå¤æ‰“æ–­
                        is_first_chunk_in_session = (self.audio_flow_control["packet_count"] == 0)
                        pre_buffer_frames = min(3, len(opus_datas)) if is_first_chunk_in_session else 0
                        for i in range(pre_buffer_frames):
                            if self.on_audio_data and opus_datas[i]:
                                self.on_audio_data(opus_datas[i])
                                # é¢„ç¼“å†²ä¹Ÿè®¡å…¥å·²å‘é€å¸§æ•°ï¼Œä¿æŒèŠ‚æ‹è¿ç»­
                                self.audio_flow_control["packet_count"] += 1
                                self.audio_flow_control["sequence"] += 1
                                self.audio_flow_control["last_send_time"] = time.perf_counter()

                        # ğŸ”¥ è¿ç»­æµæ§ï¼šæŒ‰ç´¯è®¡å·²å‘é€å¸§æ•°(packet_count)æ¨ç®—æœŸæœ›æ—¶é—´ç‚¹
                        start_time = self.audio_flow_control["start_time"]

                        # å‘é€æ‰€æœ‰éŸ³é¢‘å¸§ï¼ˆè·³è¿‡å·²é¢„ç¼“å†²çš„å¸§ï¼‰
                        for i, opus_packet in enumerate(opus_datas[pre_buffer_frames:], pre_buffer_frames):
                            if self.abort:
                                self.log(self.LOG_INFO, "æ’­æ”¾è¢«ä¸­æ­¢")
                                break

                            # è®¡ç®—æœŸæœ›å‘é€æ—¶é—´ï¼šä»ä¼šè¯start_timeèµ·ï¼ŒæŒ‰å·²å‘é€å¸§æ•° * FRAME_DURATION çº¿æ€§æ¨è¿›
                            expected_time = start_time + (
                                (self.audio_flow_control["packet_count"] * self.FRAME_DURATION) / 1000.0
                            )
                            current_time_perf = time.perf_counter()
                            delay = expected_time - current_time_perf
                            if delay > 0:
                                time.sleep(delay)

                            # æ·»åŠ æ—¶é—´æˆ³å’Œåºåˆ—å·ï¼ˆå¦‚æœéœ€è¦ï¼‰
                            if hasattr(self, 'conn_from_mqtt_gateway') and self.conn_from_mqtt_gateway:
                                timestamp, sequence = self._calculate_timestamp_and_sequence(
                                    start_time, self.audio_flow_control["packet_count"], self.FRAME_DURATION
                                )
                                header = bytearray(16)
                                header[0] = 1  # type
                                header[2:4] = len(opus_packet).to_bytes(2, "big")
                                header[4:8] = sequence.to_bytes(4, "big")
                                header[8:12] = int(timestamp).to_bytes(4, "big")
                                header[12:16] = len(opus_packet).to_bytes(4, "big")
                                complete_packet = bytes(header) + opus_packet
                                if self.on_audio_data:
                                    self.on_audio_data(complete_packet)
                            else:
                                if self.on_audio_data and opus_packet:
                                    if i < pre_buffer_frames + 3 or i >= total_chunks - 3 or i % 10 == 0:
                                        self.log(self.LOG_DEBUG, f"å‘é€éŸ³é¢‘å¸§: {i+1}/{total_chunks}, {len(opus_packet)}å­—èŠ‚")
                                    self.on_audio_data(opus_packet)

                            # æ›´æ–°æµæ§ç´¯è®¡çŠ¶æ€
                            self.audio_flow_control["packet_count"] += 1
                            self.audio_flow_control["sequence"] += 1
                            self.audio_flow_control["last_send_time"] = time.perf_counter()

                        # ä»…åœ¨æœ€ç»ˆå—å‘é€éŸ³é¢‘ç»“æŸæ ‡è®°
                        if self.on_audio_data and not self.abort and is_final_chunk:
                            self.on_audio_data(self.AUDIO_END_MARKER)
                            self.log(self.LOG_DEBUG, "å‘é€éŸ³é¢‘ç»“æŸæ ‡è®°ï¼ˆæœ€ç»ˆå—ï¼‰")

                        # è°ƒç”¨æ’­æ”¾ç»“æŸå›è°ƒ
                        if self.on_play_end and not self.abort:
                            self.on_play_end()

                    except Exception as e:
                        self.log(self.LOG_ERROR, f"æ’­æ”¾éŸ³é¢‘å¼‚å¸¸: {str(e)}")
                        traceback.print_exc()
                    finally:
                        self.audio_play_queue.task_done()

            except queue.Empty:
                continue
            except Exception as e:
                self.log(self.LOG_ERROR, f"å¤„ç†éŸ³é¢‘é˜Ÿåˆ—å¼‚å¸¸: {str(e)}")
                traceback.print_exc()
                time.sleep(0.1)

    def set_log_level(self, level):
        """è®¾ç½®æ—¥å¿—çº§åˆ«
        Args:
            level: æ—¥å¿—çº§åˆ«
        """
        self.log_level = level
        self.log(self.LOG_INFO, f"æ—¥å¿—çº§åˆ«å·²è®¾ç½®ä¸º: {level}")

    def stop_monitors(self):
        """åœæ­¢æ‰€æœ‰ç›®å½•ç›‘æ§"""
        try:
            # ç¡®ä¿å·²åˆå§‹åŒ–å±æ€§
            if not hasattr(self, 'monitored_directories'):
                self.monitored_directories = set()
                return True
                
            # ç”±äºçœŸæ­£çš„ç›‘æ§çº¿ç¨‹åœ¨stop_audio_file_monitorä¸­åœæ­¢
            # è¿™é‡Œåªéœ€è¦æ¸…ç©ºç›‘æ§ç›®å½•é›†åˆ
            prev_count = len(self.monitored_directories)
            self.monitored_directories.clear()
            
            # è®¾ç½®æ‰€æœ‰ç›‘æ§çº¿ç¨‹çš„åœæ­¢æ ‡å¿—
            self.monitor_running = False
            
            self.log(self.LOG_INFO, f"å·²åœæ­¢æ‰€æœ‰ç›®å½•ç›‘æ§ï¼Œå…± {prev_count} ä¸ª")
            return True
        except Exception as e:
            self.log(self.LOG_ERROR, f"åœæ­¢ç›‘æ§å¤±è´¥: {str(e)}")
            return False


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆ›å»ºè¾“å‡ºç®¡ç†å™¨
    audio_manager = AudioOutputManager()
    
    # è®¾ç½®å›è°ƒ
    def on_play_start(text):
        print(f"å¼€å§‹æ’­æ”¾: {text}")
    
    def on_play_end():
        print("æ’­æ”¾ç»“æŸ")
    
    def on_audio_data(data):
        print(f"éŸ³é¢‘æ•°æ®å¤§å°: {len(data)} å­—èŠ‚")
    
    audio_manager.set_callbacks(on_play_start, on_play_end, on_audio_data)
    
    # æµ‹è¯•æ’­æ”¾
    test_file = "samples/sample-001.wav"
    if os.path.exists(test_file):
        audio_manager.add_tts_task("è¿™æ˜¯ä¸€æ¡æµ‹è¯•æ¶ˆæ¯", test_file)
        time.sleep(5)  # ç­‰å¾…æ’­æ”¾å®Œæˆ
    
    # åœæ­¢ç®¡ç†å™¨
    audio_manager.stop()
    print("æµ‹è¯•å®Œæˆ")
